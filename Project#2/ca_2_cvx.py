# -*- coding: utf-8 -*-
"""CA#2_CVX.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hGf9nzxBs-7nTNFLxjG70lF7POOlrnLS
"""

import numpy as np
import cvxpy as cp
import matplotlib.pyplot as plt
import numpy as np
from kernel_svm_data import *

def is_pos_def(x):
    return np.all(np.linalg.eigvals(x) > 0)

def p_theta(x1, x2, alpha, l):
    v = (-1/l) * (y_diag @ alpha)
    return sum(
        K(val[0], val[1], x1, x2) * v[idx] for idx, val in enumerate(X)
    )

def plot_contour(alpha, l):
    N = 100
    x = np.linspace(-1.5, 1.5, N)
    y = np.linspace(-1.5, 1.5, N)

    _X, _Y = np.meshgrid(x, y)

    z = p_theta(_X, _Y, alpha, l)

    plt.contour(x, y, z, colors='black')
    plt.title(f"Contour plot with lambda = {l}", fontsize=19)
    plt.show()

lambdas = [1e-3, 1e-2, 1e0, 1e1]
epsilon = 1e-6
m = len(X)
print(f"m is: {m}")

solvers = [
           cp.ECOS,
           cp.MOSEK,
           cp.CBC,
           cp.CVXOPT,
           cp.NAG,
           cp.SCS
]

f_conjugate = lambda x: x if x >= -1 and x <= 0 else np.inf
# K = lambda x, z: (1 + x.T @ z)**6
def K(x1, x2, z1, z2):
    return (1 + x1*z1 + x2*z2)**6

G = np.zeros((m, m))
for i in range(m):
    for j in range(m):
        if j < i:
            G[i][j] = G[j][i]
        else:
            G[i][j] = K(X[i][0], X[i][1], X[j][0], X[j][1])

G = G + epsilon * np.identity(m)
y_diag = np.diag(y)

is_pos_def(G)

l_h = np.linalg.cholesky(G).T

alpha_estimations = []
alpha = cp.Variable(m)
t = cp.Variable()

constraints = [
               alpha >= -1,
               alpha <= 0,          
]

for l in lambdas:
    obj = cp.Maximize(
        -cp.sum(alpha) - (1 / (2*l)) * cp.norm(l_h @ y_diag @ alpha)**2
    )
    prob = cp.Problem(obj, constraints=constraints)
    prob.solve(
        solver=solvers[0],
        verbose=True
    )
    alpha_estimations.append(alpha.value)

for idx, alpha in enumerate(alpha_estimations):
    preds = np.array([
                      p_theta(x[0], x[1], alpha, lambdas[idx]) for x in X
    ])
    preds = np.sign(preds)
    accuracy = sum(pred==y[idx] for idx, pred in enumerate(preds)) / len(y)
    print(f"lambda: {lambdas[idx]}, accuracy is: {accuracy}")
    plot_contour(alpha, lambdas[idx])